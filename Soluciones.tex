\documentclass[10pt,a4paper,openright]{book}

%% Formateo del título del documento
\title{Soluciones de los Ejercicios, MARP I}
\author{Mario Calvarro Marines}
\date{}

%% Formateo del estilo de escritura y de la pagina
\pagestyle{plain}
\setlength{\parskip}{0.35cm} %edicion de espaciado
\setlength{\parindent}{0cm} %edicion de sangría
\clubpenalty=10000 %líneas viudas NO
\widowpenalty=10000 %líneas viudas NO
\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry} % para establecer las medidas de los margenes
\usepackage[spanish]{babel} %Para que el idioma por defecto sea español
\usepackage{ulem} % para poder subrayar entornos especiales como las secciones

%% Texto matematico y simbolos especiales
\usepackage{amsmath} %Paquetes para mates
\usepackage{amsfonts} %Paquetes para mates
\usepackage{amssymb} %Paquetes para mates
\usepackage{stmaryrd} % paquete para mates
\usepackage{latexsym} %Paquetes para mates
\usepackage{cancel} %Paquete tachar cosas
\usepackage{listings}

%% Ruta de las fotos e inclusion de las mismas
\usepackage{graphicx}
\graphicspath{{./fotos/}}

%% Inclusion de referencias cruzadas por defecto y específicas
\usepackage{hyperref}

%% Paquete para definir y utilizar colores por el documento
\usepackage[dvipsnames,usenames]{xcolor} %activar e incluir colores
    %% definicion de los colores que se van a utilizar en cada cabecera
    \definecolor{capitulos}{RGB}{60,0,0}% gama de colores de los capitulos
    \definecolor{secciones}{RGB}{95,8,5}% gama de colores de las secciones
    \definecolor{subsecciones}{RGB}{140,36,31}% gama de colores de las subsections
    \definecolor{subsubsecciones}{RGB}{188,109,79}% gama de colores de las subsubsections
    \definecolor{teoremas}{RGB}{164,56,32}% gama de colores para los teoremas
    \definecolor{demos}{RGB}{105,105,105} % gama de colores para el cuerpo de las demostraciones

%% Paquete para la edición y el formateo de capítulos, secciones...
\usepackage[explicit]{titlesec}
    %% Definición del estilo de los capítulos, secciones, etc...
    \titleformat{\chapter}[display]{\normalfont\huge\bfseries\color{capitulos}}{}{0pt}{\Huge #1}[\titlerule]
    \titleformat{\section}{\normalfont\Large\bfseries\color{secciones}}{}{0pt}{#1}
    \titleformat{\subsection}{\normalfont\large\bfseries\color{subsecciones}}{}{0pt}{\uline{#1}}
    \titleformat{\subsubsection}{\normalfont\normalsize\bfseries\color{subsubsecciones}}{}{0pt}{#1}

%% Paquete para el formateo de entornos del proyecto
\usepackage{ntheorem}[thmmarks]
    %% Definicion del aspecto de los entornos matematicos del proyecto
    \theoremstyle{break}
    \theoremheaderfont{\normalfont\bfseries\color{teoremas}}
    \theorembodyfont{\itshape}
    \theoremseparator{\vspace{0.2cm}}
    \theorempreskip{\topsep}
    \theorempostskip{\topsep}
    \theoremindent0cm
    \theoremnumbering{arabic}
    \theoremsymbol{}
    \theoremprework{\vspace{0.2cm} \hrule}
    \theorempostwork{\vspace{0.2cm}\hrule}
        \newtheorem*{defi}{Definición}

    \theoremprework{\vspace{0.25cm}}
        \newtheorem*{theo}{Teorema}

    \theoremprework{\vspace{0.25cm}}
    	\newtheorem*{coro}{Corolario}

    \theoremprework{\vspace{0.25cm}}
    	\newtheorem*{lema}{Lema}

    \theoremprework{\vspace{0.25cm}}
    	\newtheorem*{prop}{Proposición}

    \theoremheaderfont{\normalfont}
    \theorembodyfont{\normalfont\color{demos}}
    \theoremsymbol{\hfill\square}
    	\newtheorem*{demo}{\underline{Demostración}:}

    \theoremheaderfont{\normalfont}
    \theorembodyfont{\normalfont}
    	\newtheorem*{obs}{\underline{Observación}:}
    	\newtheorem*{ej}{\underline{Ejemplo}:}

%% Definicion de operadores especiales para simplificar la escritura matematica
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\img}{img}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\divg}{div}
\newcommand{\dif}[1]{\ d#1}

%% Paquete e instrucciones para la generacion de los dibujos
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage{tkz-fct}
\usepgfplotslibrary{fillbetween}
\usepackage{tikz,tikz-3dplot}
\tdplotsetmaincoords{80}{45}
\tdplotsetrotatedcoords{-90}{180}{-90}
\usetikzlibrary{arrows}
    %% style for surfaces
    \tikzset{surface/.style={draw=blue!70!black, fill=blue!40!white, fill opacity=.6}}

    %% macros to draw back and front of cones
    %% optional first argument is styling; others are z, radius, side offset (in degrees)
    \newcommand{\coneback}[4][]{
        %% start at the correct point on the circle, draw the arc, then draw to the origin of the diagram, then close the path
        \draw[canvas is xy plane at z=#2, #1] (45-#4:#3) arc (45-#4:225+#4:#3) -- (O) --cycle;
    }
    \newcommand{\conefront}[4][]{
        \draw[canvas is xy plane at z=#2, #1] (45-#4:#3) arc (45-#4:-135+#4:#3) -- (O) --cycle;
    }
    
    \tikzset{middlearrow/.style={decoration={markings, mark= at position 0.5 with {\arrow{#1}},},postaction={decorate}}}
    
    \usetikzlibrary{decorations.markings}
    
    \newcommand{\AxisRotator}[1][rotate=0]{
    \tikz [x=0.25cm,y=0.60cm,line width=.2ex,-stealth,#1] \draw (0,0) arc (-150:150:1 and 1);
    }
    
    \usetikzlibrary{shapes}


\begin{document}
\maketitle
\setcounter{tocdepth}{3}% para que salgan las subsubsecciones en el indice
\tableofcontents
\chapter{Hoja 1}%
\label{cha:hoja_1}

\section{Ejercicio 1. (Iker Muñoz)}%
\label{sec:ejercicio_1}
No será coste constante amortizado. Contraejemplo:
\begin{lstlisting}
fun multiapilar (p: pila, k: nat)
    mientras k > 0 hacer
        apilar (p)
        k = k - 1
    fmientras
ffun
\end{lstlisting}
Coste $O\left( k \right)$. Si consideramos la secuencia de $n$ llamadas a multiapilar tendremos:
\[
\hat{c_i} = \frac{1}{n} \sum_{i=1}^{n} c_i = \frac{1}{n} \sum_{i=1}^{n} k = k.  
\]

\section{Ejercicio 2. (Sergio García)}%
\label{sec:ejercicio_2}
Sí:
\[
\underbrace{1 \ldots \underbrace{10 \ldots 0}_{k - 1}}_{n} \rightarrow^{\text{incrementar}}  \underbrace{1 \ldots \underbrace{01 \ldots 1}_{k-1}}_{n} \rightarrow^{\text{decrementar}}  \underbrace{1 \ldots \underbrace{10 \ldots 0}_{k-1}}_{n} \rightarrow \ldots n \text{ operaciones.} 
\]
Incrementar y decrementar: $O\left( k \right) \Rightarrow n \text{ operaciones } O\left( nk \right)$.  

\section{Ejercicio 3. (Alba Bautista)}%
\label{sec:ejercicio_3}
Hemos de calcular $\frac{\sum_{j=1}^{n} c_j}{j}$. Lo hacemos primero para $j = 2^n$. 

Consideramos $C_{in} = \{2^i : 0 \le i \le n\}$ y $\overline{C}_{in} = \left( 1, \ldots, 2^n \right) \ C_n$. 
\[
\sum_{i=1}^{\infty} C_i = \sum_{i \in C_n} C_i + \sum_{i=1}^{n} C_i = \sum_{i=1}^{\infty} 2^i + \sum_{i \in C_n} 1 = 2^{n+1} - 1 + \mid \overline{C}_n \mid \mid \overline{C}_n\mid = \mid 1 \ldots 2^n\mid - \mid C_n \mid = 
\]\[
= 2^n - \left( n + 1 \right) \Rightarrow \sum_{i=1}^{j} C_i = \left( 2^{n + 1} - 1 \right) + \left( 2^n - n - 1 \right) = 3 \cdot 2^n - n - 2 \Rightarrow \frac{\sum_{i=1}^{j} C_i}{2^n} \le 3 \in O\left( 1 \right) 
\]
De forma similar si tomamos $j = 2^n + j': j' \in 1, \ldots, 2^n - 1$.
\[
\Rightarrow \sum_{i=0}^{j} 3\cdot 2^n - n - 2 + j \Rightarrow \frac{\sum_{i=0}^{j} C_i}{j} \le 3 \in O\left( 1 \right)    
\]
Ya que $\begin{cases}
    2^n \le j\\
    j' \le j
\end{cases} $

\section{Ejercicio 4. (Juan Fonseca)}%
\label{sec:ejercicio_4}
Utilizamos el método del potencial para calcular el coste amortizado: 

$\Phi \left( D_i \right)$ elementos en la lista tras operación i-ésima
\begin{itemize}
    \item Añadir un número: 
    \[
    \hat{c}_i = c_1 + \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right) = 1 + \left( k + 1 \right) - k = 2 \in O\left( 1 \right)
    \]
    \item Reducir-lista: 
    \[
    \hat{c}_i = c_1 + \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right) = k + 1 + 1 - k = 2 \in O\left( 1 \right)
    \]
\end{itemize}

\section{Ejercicio 5. (Marta Vicente)}%
\label{sec:ejercicio_5}
\begin{lstlisting}
proc contar(C[0, ..., k - 1] de {0, 1}, E/S posSig: nat)
    j := 0
    mientras j < k AND j < posSig AND C[j] = 1
        C[j] := 0
        j := j + 1
    fmientras

    si j < k AND j < posSig
        C[j] := 1
    fsi

    si j < k AND j = posSig
        C[j] := 1
        posSig := posSig + 1
    fsi
fproc
\end{lstlisting}

\begin{lstlisting}
proc resetear (E/S posSig: nat)
    posSig := 0
fproc
\end{lstlisting}
\[
valor\left( c \right) = \sum_{j=0}^{\text{posSig}} 2^jC\left[ j \right]  
\]

\section{Ejercicio 6. (Juan Diego Barrado)}%
\label{sec:ejercicio_6}
\underline{DISCLAMER}: Este ejercicio no está ni de cerca completo. Recomiendo no utilizar este documento para estudiarlo. 

% Faltan dibujos y la explicación no solo es incompleta sino que también es posiblemente errónea.

\underline{Buscar}:

Para cada $A_i$, hacer búsqueda binaria tiene coste en $O\left( \log 2^i \right) = O\left( i \right)$. 

En el caso peor, el elemento que buscamos está en $A_{k-1}$, luego $\sum_{i=0}^{k-1} i = \frac{\left( k-1 \right) k}{2} \in O\left( k^2 \right) = O\left( \log^2\left( n \right) \right)$.

\underline{Insertar}:
Cuando insertamos $n$ elementos como mucho viajan al nivel $\log\left( n \right)$ vaciamos $A_0$ de $1$ elemento $\frac{n}{2}$ veces, $A_1,\ 2$ elementos $\frac{n}{4}$ veces y $A_j,\ 2^j$ elementos $\frac{n}{2^{j+1}}$ veces $\Rightarrow$
\[
T\left( n \right) = \sum_{j=0}^{\log n} 2^j \cdot \frac{n}{2^{j+1}} = \frac{n}{2} \log n.
\]

\section{Ejercicio 7. (Leonardo Macías)}%
\label{sec:ejercicio_7}
Base: $b\left[ 0, \ldots, n-1 \right] \in \mathbb{Z}^n$ con $b\left[ i \right] \ge 2$.

Contador: $v\left[ 0, \ldots, n-1 \right]$ con $0 \le v\left[ i \right] < b\left[ i \right]$ y $v\left[ 0 \right]$ menos significativo.

\begin{lstlisting}
proc incrementar (b: base, v: contador) 
    i := 0
    mientras i < n AND v[i] = b[i] - 1 hacer
        v[i] := 0
        i := i + 1
    fmientras
    si i < n hacer
        v[i] := v[i] + 1
    fsi
fproc
\end{lstlisting}
$v\left[ 0 \right]$ cambia $n$ veces, $v\left[ 1 \right]$ cambia $\frac{n}{b\left[ 0 \right]}$ veces, \ldots, $v\left[ i \right]$ cambia $\frac{n}{\prod_{j=0}^{i} b\left[ j \right]}$ veces.

\underline{M. Agregación}: 
Nº Cambios: $\sum_{i=0}^{n} \frac{n}{\prod_{j=0}^{i} b\left[ j \right]}$

Como $\forall j \in \{0, \ldots, n-1\}: b\left[ j \right] \ge 2$:
\[
\sum_{i=0}^{n} \frac{1}{\prod_{j=0}^{i} b\left[ j \right]} \le \sum_{i=0}^{n} \frac{1}{2^i} \le \sum_{i=0}^{\infty} \frac{1}{2^i} = 2  
\]

\underline{Coste amortizado}:
\[
\frac{1}{n} \sum_{i=0}^{n} \frac{n}{\prod_{j=0}^{i} b\left[ j \right]} = \sum_{i=0}^{n} \frac{1}{\prod_{j=0}^{i} b\left[ j \right]} \le 2   
\]

\section{Ejercicio 8. (Beñat Pérez)}%
\label{sec:ejercicio_8}
\begin{enumerate}
\item[a)] Utilizamos dos pilas una de los elementos y otra de máximos.

Operaciones:
\begin{lstlisting}
proc apilar(p1, p2: pila; k: ent)
    si !p2.empty AND k <= p2.top =>
        p2.push(k)
    fsi
    p1.push(k)
fproc 
\end{lstlisting}

\begin{lstlisting}
proc maximo (p2: pila; k: ent)
    si !p2.empty => 
        return p2.top
    fsi
fproc
\end{lstlisting}

\begin{lstlisting}
proc desapilar(p1, p2: pila)
    si !p1.empty =>
        si p1.top = p2.top =>
            p2.pop
        fsi
    fsi
    p1.pop
fproc
\end{lstlisting}

\item[b)] Operaciones:

\begin{lstlisting}
proc anyadir(p1: pila; k: ent) 
    si !p1.empty =>
        p1.push(k, max(k, p1.top)
    si no =>
        p1.push(k, max)
    fsi
fproc
\end{lstlisting}

\begin{lstlisting}
func max(p1, p2: pila) 
    return max(p1.top.b, p2.top.b)
fproc
\end{lstlisting}

\begin{lstlisting}
proc desapilar(p1, p2: pilas; k: ent) 
    si !p2.empty =>
        si !p1.empty =>
            p2.push(p1.top.a, p1.top.a)
            p1.pop
            mientras !p1.empty hacer
                p2.push(p1.top.a, max(p1.top.a, p2.top.b)
                p1.pop
            fmientras
            p2.pop
        fsi
    si no =>
        p2.pop
    fsi
fproc
\end{lstlisting}
En el caso peor tendremos $O\left( n \right)$. Sin embargo, amortizado de $n$ operaciones nos saldrá $O\left( 1 \right)$ por operación.

Por el método de contabilidad. Asumamos que apilar tiene coste $3$ (poner el elemento en $p_1$, quitarlo de $p_1$ y ponerlo en $p_2$). Así, solamente nos queda que desapilar tiene coste $1$, ya que habría que hacer una sola operación. 

Además, la función máximo es constante. 

Con todo, nos queda que el coste amortizado es $O\left( 1 \right)$.
\end{enumerate}

\section{Ejercicio 9 (Lucía Alonso)}%
\label{sec:ejercicio_9_lucia_alonso_}
Tenemos una cola $C$, creamos una doble cola llamada $maximos$ para llevar el control del máximo de $C_1$: 
\[
    maximos[i]: 0 \le i < n : \forall j : i < j \le n: maximos[i] \le maximos[j]
\]
\begin{itemize}
    \item En la llamada a $borrar\left( \right)$ elemento de $C_1$ debemos comprobar si es $1^{er}$ máximo.
    \item En la llamada a $insertar\left( \right)$ elemento de $C_1$ debemos borrar todos los elementos de máximo menores que él.
\end{itemize}
\begin{ej}
\begin{align*}
    C = 5, 4, 3, 2, 1;&\quad maximos = 5, 4, 3, 2, 1 \Rightarrow insertar\left( 3 \right)\\
    C = 5, 4, 3, 2, 1, 3;&\quad maximos = 5, 4, 3, 3 \Rightarrow remove\left(\right)\\
    C = 4, 3, 2, 1, 3;&\quad maximos = 4, 3, 3 \Rightarrow insert\left( 6 \right)\\
    C = 4, 3, 2, 1, 3, 6;&\quad maximos = 6
.\end{align*}
\end{ej}
\begin{lstlisting}
proc insertar(cola: C1, doble cola : maximos, elemento: x)
    c.push(x)
    mientras !maximos.empty() AND maximos.back() < x 
        maximo.pop_back()
    fmientras
    maximos.push_back(x)
fproc
\end{lstlisting}

\begin{lstlisting}
proc borrar(cola: C1, doble cola: maximos) 
    si c.front() = maximos.front()
        maximos.pop_front()
    fsi
    c.pop()
fproc
\end{lstlisting}

\begin{lstlisting}
{!maximo.empty()}
func getMax(doble cola: maximo)
    return maximo.front()
ffunc
\end{lstlisting}

\underline{Coste amortizado}. Por el método del potencial.
\begin{itemize}
    \item \underline{Caso peor}: Se añade el máximo de $C$ y $maximos$ está ordenada decrecientemente:
    \[
    c_i = 4 + n \in O\left( n \right) \Rightarrow \text{Lineal.} 
    \]
    En la siguiente llamada, cola vacía: 
    \[
    c_{i+1} = 4 + 1 \in O\left( 1 \right) \Rightarrow \text{cte.} 
    \]
    \item \underline{Método del potencial}: 
    \[
    \Phi\left( D_i \right) = \text{longitud de la doble cola de máximos.} 
    \]
    Al empezar con $C$ vacía se cumple $\forall i: \Phi\left( D_i \right) - \Phi\left( D_{0} \right) > 0$.
    \begin{itemize}
        \item En la llamada a $getMax\left( \right)$: 
        \[
        \hat{c}_i = c_i + \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right) = 1 \in O\left( 1 \right)
        \] Al ser una operación de consulta.
        \item En la llamada $borrar\left(  \right)$: 
        \[
        \hat{c}_i = c_i + \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right) = \begin{cases}
            2 \text{ si no se borra el máximo}\\
            2 + m - 2 -m = 1 \text{ c.c} 
        \end{cases} 
        \]
        \item En la llamada a $insertar\left( \right)$:
        \[
        \hat{c}_i = c_i + \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right) = 4 + b_i + \left( k - b_i \right) - k = 4 \in O\left( 1 \right)
        \]
    \end{itemize}
    Es decir, el coste amortizado es \underline{constante}.
\end{itemize}

\section{Ejercicio 10 (Javier Saras)}%
\label{sec:ejercicio_10}
Por el \underline{método del potencial}. 
\[
\Phi\left( D_i \right) = M + m
\]
Con $\Phi\left( D_0 \right) = 0$ y $\Phi\left( D_i \right) \ge 0$.

\begin{itemize}
    \item $maximo\left( \right)$:
    \[
    \hat{c_i} = 1 + M + m - M - m = 1
    \]
    \item $minimo\left( \right)$:
    \[
    \hat{c_i} = 1 + M + m - M - m = 1
    \]
    \item $eliminar\left( \right)$:
    \begin{itemize}
        \item Máximo: $\hat{c}_i = 2 + M - 1 + m - M - m = 1$.
        \item Mínimo: $\hat{c}_i = 2 + M + m - 1 - M - m = 1$.
        \item Ninguno: $\hat{c}_i = 1 + M + m - M - m = 1$.
    \end{itemize}
    \item $insertar\left( \right)$:
    \begin{itemize}
        \item Máximo: $\hat{c}_i = m + 3 + 1 + m + 1 - \left( M + m \right) = 5$
        \item Mínimo: $\hat{c}_i = m + 3 + M + 1 + 1 - \left( M + m \right) = 5$
        \item Ninguno: $\hat{c}_i = a + b + 3 + M - a + 1 + m - b + 1 - \left( M + m \right) = 5$
    \end{itemize}
\end{itemize}

\section{Ejercicio 11 (Javier Amado)}%
\label{sec:ejercicio_11}
\begin{lstlisting}
class multiconj {
    valores: array <int>
    n: int
    +constructor vacio() {
        valores := new int[max]
        n := 0;
    }

    +insertar(v: int) {
        si (n < max) {
            valores[n] = v
            n := n + 1
        fsi
    }
    +elimMayores {
        nborrar := ceil(n/2)
        m := mediana(valores/n)
        i := 0; elim = 0; j = 0;
        mientras i < n
            si valores[i] > m
                valores [i] := null
                elim := elim + 1
            fsi
            i := i + 1
        fmientras
        mientras j < n AND elim < nborrar
            si valores[j] = m
                valores[j] := null
                elim := elim + 1
            fsi 
            j := j + 1
        fmientras
        i := 0; j := 0
        mientras j < n
            si valores[j] != null
                valores[i] = valores[j]
                i := i + 1
            fsi
        fmientras
        n := n - elim; f elim mayores?
    }
}
\end{lstlisting}
Coste por el método del \underline{potencial} 
\[
\Phi\left( D_i \right) = 2n
\]\[
\hat{c}_{insertar} = c_{insertar} + \left( \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right) \right) = 1 + 2 = 3 \in O\left( 1 \right) 
\]\[
\hat{c}_{elimMayores} = c_{elimMayores} + \left( \Phi\left( D_i \right) - \Phi\left( D_{i-1} \right)\right) = n - 2 \left\lfloor n/2 \right\rfloor = \begin{cases}
    0 \text{ si } n \text{ es par}\\
    1 \text{ si } n \text{ es impar} 
\end{cases} 
\]

\end{document}
